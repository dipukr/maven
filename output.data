struct StatementVisitor;

struct Statement {
	uint pos;
	Statement(uint pos) : pos(pos) {}
	virtual void accept(StatementVisitor *visitor) = 0;
};

class ClassStatement: public Statement
{
	List<Statement*> *m_variables;
	List<Statement*> *m_functions;
public:
	ClassStatement(List<Statement*> *variables, List<Statement*> *functions, uint pos);
	List<Statement*>* variables() const;
	List<Statement*>* functions() const;
	void accept(StatementVisitor *visitor);
};

class FunctionStatement: public Statement
{
	String m_name;
	List<String> *m_params;
	List<Statement*> *m_statements;
public:
	FunctionStatement(String name, List<String> *params, List<Statement*> *statements, uint pos);
	String name() const;
	List<String>* params() const;
	List<Statement*>* statements() const;
	void accept(StatementVisitor *visitor);
};

class BlockStatement: public Statement
{
	List<Statement*> *m_statements;
public:
	BlockStatement(List<Statement*> *statements, uint pos);
	List<Statement*>* statements() const;
	void accept(StatementVisitor *visitor);
};

class VarStatement: public Statement
{
	String m_name;
	Expression *m_value;
public:
	VarStatement(String name, Expression *value, uint pos);
	String name() const;
	Expression* value() const;
	void accept(StatementVisitor *visitor);
};

class ValStatement: public Statement
{
	String m_name;
	Expression *m_value;
public:
	ValStatement(String name, Expression *value, uint pos);
	String name() const;
	Expression* value() const;
	void accept(StatementVisitor *visitor);
};

class IfStatement: public Statement
{
	Expression *m_condition;
	Statement *m_statement0;
	Statement *m_statement1;
public:
	IfStatement(Expression *condition, Statement *statement0, Statement *statement1, uint pos);
	Expression* condition() const;
	Statement* statement0() const;
	Statement* statement1() const;
	void accept(StatementVisitor *visitor);
};

class WhileStatement: public Statement
{
	Expression *m_condition;
	Statement *m_statement;
public:
	WhileStatement(Expression *condition, Statement *statement, uint pos);
	Expression* condition() const;
	Statement* statement() const;
	void accept(StatementVisitor *visitor);
};

class ForeachStatement: public Statement
{
	String m_name;
	String m_target;
public:
	ForeachStatement(String name, String target, uint pos);
	String name() const;
	String target() const;
	void accept(StatementVisitor *visitor);
};

class BreakStatement: public Statement
{
public:
	BreakStatement(uint pos);
	void accept(StatementVisitor *visitor);
};

class ReturnStatement: public Statement
{
	Expression *m_value;
public:
	ReturnStatement(Expression *value, uint pos);
	Expression* value() const;
	void accept(StatementVisitor *visitor);
};

class ExpressionStatement: public Statement
{
	Expression *m_expression;
public:
	ExpressionStatement(Expression *expression, uint pos);
	Expression* expression() const;
	void accept(StatementVisitor *visitor);
};

struct StatementVisitor {
	virtual void visit(ClassStatement *statement) = 0;
	virtual void visit(FunctionStatement *statement) = 0;
	virtual void visit(BlockStatement *statement) = 0;
	virtual void visit(VarStatement *statement) = 0;
	virtual void visit(ValStatement *statement) = 0;
	virtual void visit(IfStatement *statement) = 0;
	virtual void visit(WhileStatement *statement) = 0;
	virtual void visit(ForeachStatement *statement) = 0;
	virtual void visit(BreakStatement *statement) = 0;
	virtual void visit(ReturnStatement *statement) = 0;
	virtual void visit(ExpressionStatement *statement) = 0;
};

ClassStatement::ClassStatement(List<Statement*> *variables, List<Statement*> *functions, uint pos) : m_variables(variables), m_functions(functions), Statement(pos) {}
FunctionStatement::FunctionStatement(String name, List<String> *params, List<Statement*> *statements, uint pos) : m_name(name), m_params(params), m_statements(statements), Statement(pos) {}
BlockStatement::BlockStatement(List<Statement*> *statements, uint pos) : m_statements(statements), Statement(pos) {}
VarStatement::VarStatement(String name, Expression *value, uint pos) : m_name(name), m_value(value), Statement(pos) {}
ValStatement::ValStatement(String name, Expression *value, uint pos) : m_name(name), m_value(value), Statement(pos) {}
IfStatement::IfStatement(Expression *condition, Statement *statement0, Statement *statement1, uint pos) : m_condition(condition), m_statement0(statement0), m_statement1(statement1), Statement(pos) {}
WhileStatement::WhileStatement(Expression *condition, Statement *statement, uint pos) : m_condition(condition), m_statement(statement), Statement(pos) {}
ForeachStatement::ForeachStatement(String name, String target, uint pos) : m_name(name), m_target(target), Statement(pos) {}
BreakStatement::BreakStatement(uint pos) : Statement(pos) {}
ReturnStatement::ReturnStatement(Expression *value, uint pos) : m_value(value), Statement(pos) {}
ExpressionStatement::ExpressionStatement(Expression *expression, uint pos) : m_expression(expression), Statement(pos) {}

List<Statement*>* ClassStatement::variables() const {return m_variables;}
List<Statement*>* ClassStatement::functions() const {return m_functions;}
String FunctionStatement::name() const {return m_name;}
List<String>* FunctionStatement::params() const {return m_params;}
List<Statement*>* FunctionStatement::statements() const {return m_statements;}
List<Statement*>* BlockStatement::statements() const {return m_statements;}
String VarStatement::name() const {return m_name;}
Expression* VarStatement::value() const {return m_value;}
String ValStatement::name() const {return m_name;}
Expression* ValStatement::value() const {return m_value;}
Expression* IfStatement::condition() const {return m_condition;}
Statement* IfStatement::statement0() const {return m_statement0;}
Statement* IfStatement::statement1() const {return m_statement1;}
Expression* WhileStatement::condition() const {return m_condition;}
Statement* WhileStatement::statement() const {return m_statement;}
String ForeachStatement::name() const {return m_name;}
String ForeachStatement::target() const {return m_target;}
Expression* ReturnStatement::value() const {return m_value;}
Expression* ExpressionStatement::expression() const {return m_expression;}

void ClassStatement::accept(StatementVisitor *visitor) {visitor->visit(this);}
void FunctionStatement::accept(StatementVisitor *visitor) {visitor->visit(this);}
void BlockStatement::accept(StatementVisitor *visitor) {visitor->visit(this);}
void VarStatement::accept(StatementVisitor *visitor) {visitor->visit(this);}
void ValStatement::accept(StatementVisitor *visitor) {visitor->visit(this);}
void IfStatement::accept(StatementVisitor *visitor) {visitor->visit(this);}
void WhileStatement::accept(StatementVisitor *visitor) {visitor->visit(this);}
void ForeachStatement::accept(StatementVisitor *visitor) {visitor->visit(this);}
void BreakStatement::accept(StatementVisitor *visitor) {visitor->visit(this);}
void ReturnStatement::accept(StatementVisitor *visitor) {visitor->visit(this);}
void ExpressionStatement::accept(StatementVisitor *visitor) {visitor->visit(this);}

